## JAVA
* 운영체제에 독립적이다. JVM 위에서 동작하기 때문에 OS에 종속되지 않는다.
* 객체 지향 언어이다. 캡슐화, 상속 등을 지원한다.
* Garbage Collerctor에 의해서 메모리가 자동으로 관리된다.

## 타입
* Primitive Type(원시 타입)
  - Int, double, boolean과 같은 기본 타입.
  - 원시타입들은 항상 값이 있는 상태. 즉, Null이 될 수 없다.
  - 데이터가 저장될 때, 데이터 자체가 메모리에 할당된다.
* Reference Type(참조 타입)
  - 원시 타입을 제외한 모든 타입, Heap에 할당되고, new 키워드로 생성.
  - 생성된 객체를 할당할 때, 값이 아닌 참조하는 메모리 위치를 넘겨줌.
  - new ArrayList[20] => 데이터를 저장하는데 필요한 영역을 메모리에 요구.
  - List myList = new ArrayList[20] 구문으로 생성된 객체를 변수에 할당할 때, myList는  
    할당된 메모리 위치를 넘겨받는다.
  
## 객체와 클래스
* 객체? 간단하거나 복잡한 개체와 개체들에 관련된 연산을 제공하는 메소드의 집합.
* 클래스? 객체를 만들어내기 위한 틀, 객체의 내부상태나 구현방법들을 정의한 것.
* 인스턴스? 객체가 메모리에 할당되어 실제 사용되는 것.(JVM 메모리에 올라간 상태)
  - ex) 객체는 클래스의 인스턴스이다.

## final과 static 키워드
* final
  - 변수 정의에서 지정된 값처럼 일단 할당되고 나면 메모리 위치가 변하지 않게하기 위해 사용.
  - 객체에 final로 선언시, 참조는 변경할 수 없어도 객체 내부의 값들은 개별값이 final아니면 변경가능.
* static
  - 변수나 메소드를 클래스 내부에 정의 하지만 인스턴스에 속하지 않게 하기 위해 사용하는 키워드. => 정적메소드, 정적변수
  - 클래스 이름을 통해 정적메소드와 정적 변수에 접근. 그래서 인스턴스 생성안하고도 사용할 수 있다.
  - static 키워드가 붙은 변수는 클래스가 메모리에 올라갈 때, 자동적으로 생성되기에 인스턴스 생성 안하고도 사용가능한 것.
  - 사용할 때? 인스턴스를 생성하면 각 인스턴스들은 독립적이기 때문에 일관된 값이 필요할 때 사용.

## 접근제어자
* private
  - 같은 클래스의 모든 인스턴스에서 접근가능. 하위 클래스에서 접근 불가능(같은 클래스 내에서만)
* protected
  - 모든 하위 클래스에서 접근 가능
* public
  - 어디서든 접근가능(접근 제한 없음)
* default
  - 같은 패키지의 모든 클래스에서 접근 가능
  
## 추상클래스와 인터페이스
* 추상클래스
  - 반드시 하나 이상의 추상메소드를 가지고 객체를 생성할 수 없는 클래스.
  - 하지만 슈퍼클래스로 사용할 수있고, 사용하기 위해서는 추상클래스 override 해야함.
* 인터페이스
  - 추상메소드로만 이루어진 클래스, 메소드의 선언만 가능하다.
  
## Generic(제네릭)
* 파라미터화 된 타입. 원시타입은 제네릭 타입 정의에 사용할 수 없다.
* 클래스에서 사용할 타입을 인스턴스가 생성되는 시점에 확정지을 수 있게 하는 방법.
*  List<Integer>와 같은 것.
*  '?' 키워드는 와일드 카드라하며 컴파일러에게 A클래스를 확정한 모든 인스턴스를 사용할 수 있게 하라고 전달.

## 오토박싱과 언박싱
* Wrapper 클래스
  - 원시타입을 객체로 사용해야할 때, 사용하는 클래스
  
## 리플렉션
* 구체적인 클래스 타입을 알지 못해도, 컴파일된 바이트 코드를 통해 역으로 클래스의 정보를 알아내서 클래스를  
  사용할 수 있는 기법. 클래스의 내부정보 조회, 조작

## 어노테이션
* 사전적으로는 '주석'이라는 의미인데, 의미대로 자바 코드에 어노테이션을 달아 의미를 부여하는 기능.  
이 의미는 컴파일이나 런타임에 해석된다. 주로 메타데이터 기능을 사용하기 위해 쓴다.
* ex) @Override : 선언한 메소드가 오버라이드 되었다라는 의미.
